# -*- coding: utf-8 -*-
# @Author: Rafael Direito
# @Date:   2024-10-11 14:16:23
# @Last Modified by:   Rafael Direito
# @Last Modified time: 2025-06-21 16:57:28
import kopf
from kubernetes import client
from kubernetes.client import CoreV1Api
import requests
import json 

from config import Config
from itav_network_slice_manager import ITAvNetworkSliceManager

# Set up logging
logger = Config.setup_logging()

class NetSliceCRHandler:

    def __init__(
        self,
        slice_manager: ITAvNetworkSliceManager,
        custom_objects_api: CoreV1Api
    ):
        self.slice_manager = slice_manager
        self.custom_objects_api = custom_objects_api
        
    def process_nslice_event(
        self, event: str, spec: dict, metadata: dict
        ) -> None:

        cr_name = metadata['name']
        cr_namespace = metadata['namespace']

        if event == "ADD":
            logger.info(
                f"A resource with group: {Config.cr_group}, "
                f"version: {Config.cr_version}, plural: {Config.cr_plural} "
                f"was CREATED. This resource is named '{cr_name}' and was "
                f"deployed in namespace '{cr_namespace}'. Will now parse this "
                "resource and  request the creation of a Network Slice via "
                f"ITAvNetworkSliceManager (url={self.slice_manager.base_url})"
            )
        elif event == "UPDATE":
            logger.info(
            f"A resource with group: {Config.cr_group}, "
            f"version: {Config.cr_version}, plural: {Config.cr_plural} "
            f"was UPDATED. This resource is named '{cr_name}' and was "
            f"deployed in namespace '{cr_namespace}'. "
            f"Resource: {spec}"
        )

        # Make request to the Slice Manager
        should_apply_cr, enforcement_result = self.slice_manager \
            .enforce_network_slice(
                spec, self._spec_params_to_nslice_create_payload(spec)
            )

        if should_apply_cr:
            self.process_network_slice_enforcement(
                cr_namespace, cr_name, enforcement_result
            )
        
    
    def _spec_params_to_nslice_create_payload(self, spec):

        nslice_spec = spec["itav-netslice"]

        # Generated by AI
        payload = {
            "id": nslice_spec.get("id"),
            
            "administrative_state": nslice_spec.get("administrativeState"),

            "operational_state": nslice_spec.get("operationalState"),

            "coverage_area": nslice_spec.get("coverageArea").split(",")
            if nslice_spec.get("coverageArea") else None,

            "sst": int(nslice_spec.get("sstSnssai", {}).get("sst"))
            if nslice_spec.get("sstSnssai", {}).get("sst") is not None
            else None,

            "sd": nslice_spec.get("sstSnssai", {}).get("sd")
            if nslice_spec.get("sstSnssai") else None,
            
            "dnn": nslice_spec.get("dnn"),
            
            "prioritylabel": int(nslice_spec.get("priorityLabel"))
            if nslice_spec.get("priorityLabel") is not None
            else None,
            
            "uemobilitylevel": nslice_spec.get("ueMobilityLevel"),
            
            "reliability": float(nslice_spec.get("reliability"))
            if nslice_spec.get("reliability") is not None else None,
            
            "ulmaxpktsize": int(nslice_spec.get("maxPacketSize", {})
                                .get("maximumSize"))
            if nslice_spec.get("maxPacketSize", {}).get("maximumSize")
            is not None else None,
            
            "dllatency": int(nslice_spec.get("latency", {}).get("dl"))
            if nslice_spec.get("latency", {}).get("dl") is not None
            else None,
            
            "ullatency": int(nslice_spec.get("latency", {}).get("ul"))
            if nslice_spec.get("latency", {}).get("ul") is not None
            else None,
            
            "delaytolerance": nslice_spec.get("delayToleranceSupport"),
            
            "dldeterministiccomm": nslice_spec
            .get("deterministicCommunication", {}).get("dl", {})
            .get("availability")

            if nslice_spec.get("deterministicCommunication") else None,
            "dldeterminperiodicity": int(nslice_spec.get(
                "deterministicCommunication", {})
                .get("dl", {}).get("periodicity"))
            
            if nslice_spec.get("deterministicCommunication", {}).get("dl", {})
            .get("periodicity") is not None else None,

            "uldeterministiccomm": nslice_spec
            .get("deterministicCommunication", {}).get("ul", {})
            .get("availability")

            if nslice_spec.get("deterministicCommunication") else None,
            
            "uldeterminperiodicity": int(nslice_spec.get(
                "deterministicCommunication", {})
                .get("ul", {}).get("periodicity"))
            if nslice_spec.get("deterministicCommunication", {})
            .get("ul", {}).get("periodicity") is not None else None,
            
            "dlguathptperue": int(nslice_spec.get("dlThroughputPerUE", {})
                                .get("guaranteedThroughput"))
            if nslice_spec.get("dlThroughputPerUE", {})
            .get("guaranteedThroughput") is not None else None,
            
            "ulguathptperue": int(nslice_spec.get("ulThroughputPerUE", {})
                                .get("guaranteedThroughput"))
            if nslice_spec.get("ulThroughputPerUE", {})
            .get("guaranteedThroughput") is not None else None,
            
            "dlmaxthptperue": int(nslice_spec.get("dlThroughputPerUE", {})
                                .get("maximumThroughput"))
            if nslice_spec.get("dlThroughputPerUE", {})
            .get("maximumThroughput") is not None else None,
            
            "ulmaxthptperue": int(nslice_spec.get("ulThroughputPerUE", {})
                                .get("maximumThroughput"))
            if nslice_spec.get("ulThroughputPerUE", {})
            .get("maximumThroughput") is not None else None,
            
            "dlguathptperslice": int(nslice_spec.get(
                "dlThroughputPerSlice", {}).get("guaranteedThroughput"))
            if nslice_spec.get("dlThroughputPerSlice", {})
            .get("guaranteedThroughput") is not None else None,
            
            "ulguathptperslice": int(nslice_spec.get(
                "ulThroughputPerSlice", {}).get("guaranteedThroughput"))
            if nslice_spec.get("ulThroughputPerSlice", {})
            .get("guaranteedThroughput") is not None else None,
            
            "dlmaxthptperslice": int(nslice_spec.get(
                "dlThroughputPerSlice", {}).get("maximumThroughput"))
            if nslice_spec.get("dlThroughputPerSlice", {})
            .get("maximumThroughput") is not None else None,
            
            "ulmaxthptperslice": int(nslice_spec.get(
                "ulThroughputPerSlice", {}).get("maximumThroughput"))
            if nslice_spec.get("ulThroughputPerSlice", {})
            .get("maximumThroughput") is not None else None,

            "termdensity": int(nslice_spec.get("termDensity"))
            if nslice_spec.get("termDensity") is not None else None,

            "maxnumberofpdusessions": int(nslice_spec.get(
                "maxNumberOfPduSessions"))
            if nslice_spec.get("maxNumberOfPduSessions") is not None
            else None,

            "maxnumberofues": int(nslice_spec.get("maxNumberOfUes"))
            if nslice_spec.get("maxNumberOfUes") is not None else None,

            "n6protection": json.loads(nslice_spec.get("n6Protection")) 
            if nslice_spec.get("n6Protection") else None
        }

        # Remove any keys where the value is None
        payload = {k: v for k, v in payload.items() if v is not None}

        logger.info(
            "JSON Payload for the Slice Manager: "
            f"{json.dumps(payload, indent=4)}"
        )

        return payload


    
    def process_network_slice_enforcement(
        self, namespace: str, name: str, enforcement_result: dict
        ) -> None:

        patch = {
            "spec": {
                "itav-netslice-enforcement": enforcement_result
            }
        }
    
        try:
            # Apply the patch to update 'spec.data2' of the custom resource
            self.custom_objects_api.patch_namespaced_custom_object(
                group=Config.cr_group,
                version=Config.cr_version,
                namespace=namespace,
                plural=Config.cr_plural,
                name=name,
                body=patch
            )
            logger.info(
                f"Updated 'spec.itav-netslice-enforcement' for {name} in "
                f"{namespace} to {enforcement_result}")

        except client.exceptions.ApiException as e:
            logger.error(
                "Exception when updating 'spec.itav-netslice-enforcement' "
                f"in custom resource: {e}")
    

