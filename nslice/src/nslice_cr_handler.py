import kopf
from kubernetes import client, config, watch
from kubernetes.client import CoreV1Api
from kubernetes.client.models.v1_pod import V1Pod
from kubernetes.client.models.v1_container_status import V1ContainerStatus
import requests
import json 

from config import Config
from itav_network_slice_manager import ITAvNetworkSliceManager

# Set up logging
logger = Config.setup_logging()

class NSliceCRHandler:

    def __init__(self, slice_manager: ITAvNetworkSliceManager):
        self.slice_manager = slice_manager
        
    def process_nslice_add_event(self, spec: dict) -> None:

        logger.info(
            f"A resource with group: {Config.cr_group}, "
            f"version: {Config.cr_version}, plural: {Config.cr_plural} "
            "was created. Will now parse this resource and request the "
            "creation of a Network Slice via ITAvNetworkSliceManager "
            f"(url={self.slice_manager.base_url})"
        )

        payload_slice_manager = self._spec_params_to_nslice_create_payload(
            spec
        )
    
    def _spec_params_to_nslice_create_payload(self, spec):

        # Generated by AI
        payload = {
            "id": spec.get("id"),
            
            "administrative_state": spec.get("administrativeState"),

            "operational_state": spec.get("operationalState"),

            "coverage_area": spec.get("coverageArea").split(",")
            if spec.get("coverageArea") else None,

            "sst": int(spec.get("sstSnssai", {}).get("sst"))
            if spec.get("sstSnssai", {}).get("sst") is not None
            else None,

            "sd": spec.get("sstSnssai", {}).get("sd")
            if spec.get("sstSnssai") else None,
            
            "dnn": spec.get("dnn"),
            
            "prioritylabel": int(spec.get("priorityLabel"))
            if spec.get("priorityLabel") is not None
            else None,
            
            "uemobilitylevel": spec.get("ueMobilityLevel"),
            
            "reliability": float(spec.get("reliability"))
            if spec.get("reliability") is not None else None,
            
            "ulmaxpktsize": int(spec.get("maxPacketSize", {})
                                .get("maximumSize"))
            if spec.get("maxPacketSize", {}).get("maximumSize")
            is not None else None,
            
            "dllatency": int(spec.get("latency", {}).get("dl"))
            if spec.get("latency", {}).get("dl") is not None
            else None,
            
            "ullatency": int(spec.get("latency", {}).get("ul"))
            if spec.get("latency", {}).get("ul") is not None
            else None,
            
            "delaytolerance": spec.get("delayToleranceSupport"),
            
            "dldeterministiccomm": spec.get("deterministicCommunication", {})
            .get("dl", {}).get("availability")

            if spec.get("deterministicCommunication") else None,
            "dldeterminperiodicity": int(spec.get(
                "deterministicCommunication", {})
                .get("dl", {}).get("periodicity"))
            
            if spec.get("deterministicCommunication", {}).get("dl", {})
            .get("periodicity") is not None else None,

            "uldeterministiccomm": spec.get("deterministicCommunication", {})
            .get("ul", {}).get("availability")

            if spec.get("deterministicCommunication") else None,
            
            "uldeterminperiodicity": int(spec.get(
                "deterministicCommunication", {})
                .get("ul", {}).get("periodicity"))
            if spec.get("deterministicCommunication", {})
            .get("ul", {}).get("periodicity") is not None else None,
            
            "dlguathptperue": int(spec.get("dlThroughputPerUE", {})
                                .get("guaranteedThroughput"))
            if spec.get("dlThroughputPerUE", {})
            .get("guaranteedThroughput") is not None else None,
            
            "ulguathptperue": int(spec.get("ulThroughputPerUE", {})
                                .get("guaranteedThroughput"))
            if spec.get("ulThroughputPerUE", {})
            .get("guaranteedThroughput") is not None else None,
            
            "dlmaxthptperue": int(spec.get("dlThroughputPerUE", {})
                                .get("maximumThroughput"))
            if spec.get("dlThroughputPerUE", {})
            .get("maximumThroughput") is not None else None,
            
            "ulmaxthptperue": int(spec.get("ulThroughputPerUE", {})
                                .get("maximumThroughput"))
            if spec.get("ulThroughputPerUE", {})
            .get("maximumThroughput") is not None else None,
            
            "dlguathptperslice": int(spec.get(
                "dlThroughputPerSlice", {}).get("guaranteedThroughput"))
            if spec.get("dlThroughputPerSlice", {})
            .get("guaranteedThroughput") is not None else None,
            
            "ulguathptperslice": int(spec.get(
                "ulThroughputPerSlice", {}).get("guaranteedThroughput"))
            if spec.get("ulThroughputPerSlice", {})
            .get("guaranteedThroughput") is not None else None,
            
            "dlmaxthptperslice": int(spec.get(
                "dlThroughputPerSlice", {}).get("maximumThroughput"))
            if spec.get("dlThroughputPerSlice", {})
            .get("maximumThroughput") is not None else None,
            
            "ulmaxthptperslice": int(spec.get(
                "ulThroughputPerSlice", {}).get("maximumThroughput"))
            if spec.get("ulThroughputPerSlice", {})
            .get("maximumThroughput") is not None else None,

            "termdensity": int(spec.get("termDensity"))
            if spec.get("termDensity") is not None else None,

            "maxnumberofpdusessions": int(spec.get(
                "maxNumberOfPduSessions"))
            if spec.get("maxNumberOfPduSessions") is not None
            else None,

            "maxnumberofues": int(spec.get("maxNumberOfUes"))
            if spec.get("maxNumberOfUes") is not None else None,

            "n6protection": json.loads(spec.get("n6Protection")) 
            if spec.get("n6Protection") else None
        }

        # Remove any keys where the value is None
        payload = {k: v for k, v in payload.items() if v is not None}

        logger.info(
            "JSON Payload for the Slice Manager: "
            f"{json.dumps(payload, indent=4)}"
        )

        return payload


    
    #def process_network_slice_profile_enforcement(self, namespace: str, name: str, slice_profile: str) -> None:
    #    
    #    profile_enforcement_result = self.slice_manager.enforce_profile(
    #        slice_profile
    #    )
    #    
    #    # Define the patch payload to update 
    #    patch = {
    #        "spec": {
    #            "profile-enforcement": profile_enforcement_result
    #        }
    #    }
    #
    #    try:
    #        # Apply the patch to update 'spec.data2' of the custom resource
    #        self.custom_objects_api.patch_namespaced_custom_object(
    #            group=Config.cr_group,
    #            version=Config.cr_version,
    #            namespace=namespace,
    #            plural=Config.cr_plural,
    #            name=name,
    #            body=patch
    #        )
    #        logger.info(f"Updated 'spec.profile-enforcement' for {name} in {namespace} to {profile_enforcement_result}")
    #    except client.exceptions.ApiException as e:
    #        logger.error(f"Exception when updating 'spec.profile-enforcement' in custom resource: {e}")
    #

